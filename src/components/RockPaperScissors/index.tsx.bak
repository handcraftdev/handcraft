'use client';

import { useState, useEffect, lazy, Suspense } from 'react';
import dynamic from 'next/dynamic';
import { useSession } from 'next-auth/react';

// Pre-load the championship component
const SeasonalChampionship = dynamic(() => import('../SeasonalChampionship'), {
  loading: () => (
    <div className="p-4 text-center">
      <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-purple-500 mx-auto mb-4"></div>
      <p>Loading championship data...</p>
      <p className="text-sm text-gray-600 mt-2">
        The Seasonal Championship allows you to compete with other players for rewards!
      </p>
    </div>
  ),
  ssr: false
});
// Import the EnergyPurchase component
import EnergyPurchase from './components/EnergyPurchase';
import { useEnergy } from '@/contexts/EnergyContext';
import { useElementalEssences } from '@/contexts/ElementalEssencesContext';
import { useSeasonalChampionship } from '@/contexts/SeasonalChampionshipContext';
import { useMiniKit } from '@worldcoin/minikit-js/minikit-provider';

// Import sub-components
import GameHeader from './components/GameHeader';
import GameArena from './components/GameArena';
import GameControls from './components/GameControls';
import StatusBar from './components/StatusBar';
import VerificationOverlay from './components/VerificationOverlay';
import ResultOverlay from './components/ResultOverlay';
import TabNavigation, { TabType } from './components/TabNavigation';
import HistoryTab from './components/HistoryTab';
import StatisticsTab from './components/StatisticsTab';

// Import types and utilities
import { Choice, Result, DifficultyLevel, VerificationState, EssenceAward, ChampionshipAward } from './types';
import { getResultMessage, getStatusBarStyle, generateComputerChoice, determineResult } from './utils';
import { requestVerification, verifyProof } from './services/verification';

// Import styles
import './styles.css';
import './styles/theme.css';

export const RockPaperScissors = () => {
  // Tab navigation state
  const [activeTab, setActiveTab] = useState<TabType>('play');

  // Initialize difficulty first, since other state depends on it
  const [difficulty, setDifficulty] = useState<DifficultyLevel>(() => {
    // Only run in browser environment
    if (typeof window !== 'undefined') {
      const savedDifficulty = localStorage.getItem('rps-difficulty');
      // Validate that the saved value is a valid difficulty level
      if (savedDifficulty === 'easy' || savedDifficulty === 'medium' || savedDifficulty === 'hard') {
        return savedDifficulty as DifficultyLevel;
      }
    }
    return 'easy'; // Default to 'easy' if no valid saved value
  });

  // Stats tab selection with persistence
  const [statsTabSelection, setStatsTabSelection] = useState<string>(() => {
    // Only run in browser environment
    if (typeof window !== 'undefined') {
      const savedStatsTab = localStorage.getItem('rps-stats-tab');
      // Validate that the saved value is a valid tab
      if (savedStatsTab === 'all' || savedStatsTab === 'easy' ||
          savedStatsTab === 'medium' || savedStatsTab === 'hard') {
        return savedStatsTab;
      }
    }
    return 'all'; // Default to 'all' if no valid saved value
  });
  
  // Game state
  const [playerChoice, setPlayerChoice] = useState<Choice | null>(null);
  const [computerChoice, setComputerChoice] = useState<Choice | null>(null);
  const [gameResult, setGameResult] = useState<Result>(null);
  
  // Game statistics tracking by difficulty with localStorage persistence
  const [gameStats, setGameStats] = useState<{
    easy: {wins: number, draws: number, losses: number},
    medium: {wins: number, draws: number, losses: number},
    hard: {wins: number, draws: number, losses: number}
  }>(() => {
    // Only run in browser environment
    if (typeof window !== 'undefined') {
      const savedStats = localStorage.getItem('rps-game-stats');
      if (savedStats) {
        try {
          const parsedStats = JSON.parse(savedStats);

          // Handle migration from old format (flat object) to new format (per difficulty)
          if (parsedStats && typeof parsedStats === 'object') {
            // Check if it's the old format (has direct wins/draws/losses properties)
            if ('wins' in parsedStats && 'draws' in parsedStats && 'losses' in parsedStats) {
              // Migration from old format to per-difficulty format
              const migratedStats = {
                easy: { wins: 0, draws: 0, losses: 0 },
                medium: { wins: 0, draws: 0, losses: 0 },
                hard: { wins: 0, draws: 0, losses: 0 }
              };
              // Migrate old stats to current difficulty
              migratedStats[difficulty] = { 
                wins: parsedStats.wins || 0, 
                draws: parsedStats.draws || 0, 
                losses: parsedStats.losses || 0 
              };
              return migratedStats;
            }

            // Make sure all difficulty levels exist (for compatibility)
            const newStats = {
              easy: { wins: 0, draws: 0, losses: 0 },
              medium: { wins: 0, draws: 0, losses: 0 },
              hard: { wins: 0, draws: 0, losses: 0 },
              ...parsedStats
            };

            return newStats;
          }
        } catch (e) {
          // Failed to parse saved game stats
        }
      }
    }
    // Default empty stats for each difficulty
    return {
      easy: { wins: 0, draws: 0, losses: 0 },
      medium: { wins: 0, draws: 0, losses: 0 },
      hard: { wins: 0, draws: 0, losses: 0 }
    };
  });

  // Game history tracking with localStorage persistence
  const [gameHistory, setGameHistory] = useState<Array<{
    id: string;
    date: string;
    playerChoice: string;
    computerChoice: string;
    result: string;
    difficulty?: string; // Optional for backward compatibility
  }>>(() => {
    // Only run in browser environment
    if (typeof window !== 'undefined') {
      const savedHistory = localStorage.getItem('rps-game-history');
      if (savedHistory) {
        try {
          const parsedHistory = JSON.parse(savedHistory);

          // Add difficulty field to any existing history items that don't have it
          if (Array.isArray(parsedHistory)) {
            return parsedHistory.map(game => {
              // If the game already has a difficulty, keep it
              if (game.difficulty) {
                return game;
              }
              // Otherwise add the current difficulty
              return {
                ...game,
                difficulty // Current difficulty from useState
              };
            });
          }
          return parsedHistory;
        } catch (e) {
          // Failed to parse saved game history
        }
      }
    }
    return [];
  });
  
  const [gameActive, setGameActive] = useState(true);
  const [loadingResult, setLoadingResult] = useState(false);
  const [essenceAwarded, setEssenceAwarded] = useState<EssenceAward | null>(null);
  const [championshipAwarded, setChampionshipAwarded] = useState<ChampionshipAward | null>(null);

  // No timeout ref needed for direct cancellation approach

  // Verification states
  const [verifying, setVerifying] = useState(false);
  const [verificationChoice, setVerificationChoice] = useState<Choice | null>(null);
  const [verificationState, setVerificationState] = useState<VerificationState>(undefined);
  const [verificationError, setVerificationError] = useState<string | null>(null);

  // Add a listener to detect clicks outside World ID verification dialog
  useEffect(() => {
    // Only run while verification is active
    if (!verifying) return;

    // This listener helps detect when a user clicks outside the World ID verification dialog
    const handleClickOutside = () => {
      // Give enough time for proper cancellation to be detected first (300ms)
      // This prevents race conditions with the normal cancellation flow
      setTimeout(() => {
        // Only trigger if we're still in pending state (verification hasn't completed or been cancelled properly)
        if (verificationState === 'pending' && verifying) {
          console.warn('Click outside verification detected - resetting verification state');
          handleCancellation();
        }
      }, 300);
    };

    // Set a short timeout before adding the listener (gives time for World ID dialog to open)
    const listenerTimeout = setTimeout(() => {
      document.addEventListener('click', handleClickOutside);
    }, 2000);

    // Cleanup listener when verification state changes
    return () => {
      document.removeEventListener('click', handleClickOutside);
      clearTimeout(listenerTimeout);
    };
  }, [verifying, verificationState]);

  // Use global contexts
  const { energy, consumeEnergy } = useEnergy();
  const { addEssence, calculateReward } = useElementalEssences();
  const { isInstalled } = useMiniKit();
  const { data: session } = useSession();

  // Log when component mounts
  useEffect(() => {
    // Component mounted
  }, []);

  // Track difficulty changes
  useEffect(() => {
    // Difficulty changed
  }, [difficulty]);

  // Save stats tab selection to localStorage when it changes
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('rps-stats-tab', statsTabSelection);
    }
  }, [statsTabSelection]);

  // Save game statistics to localStorage when they change
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('rps-game-stats', JSON.stringify(gameStats));
    }
  }, [gameStats]);

  // Save game history to localStorage when it changes
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('rps-game-history', JSON.stringify(gameHistory));
    }
  }, [gameHistory]);

  // Reset the current round
  const resetRound = () => {
    // Reset round
    setPlayerChoice(null);
    setComputerChoice(null);
    setGameResult(null);
    setLoadingResult(false);
    setEssenceAwarded(null);
    setChampionshipAwarded(null); // Reset championship award
    setGameActive(true);
  };

  // Reset the current round only (preserve stats and history)
  const resetGame = () => {
    // Reset current game round;
    resetRound();
    // No longer resets game stats or history
  };

  // Get championship context at component level
  // This fixes the issue with trying to use hooks inside callbacks
  const championship = useSeasonalChampionship();

  // Check if player is a league player
  const isChampionshipPlayer = championship &&
    championship.currentSeason &&
    championship.playerStats &&
    championship.playerStats.hasEntryTicket;

  // Check if player has energy credits available
  const hasEnergyCredits = isChampionshipPlayer &&
    championship.playerStats.reserveEnergy > 0;

  // Calculate if player has any form of energy available (regular or credits)
  const hasAvailableEnergy = energy > 0 || hasEnergyCredits;

  // Process the game move after successful verification
  const processGameMove = async (choice: Choice) => {
    // Check if player has enough energy (regular energy or energy credits)
    if (!gameActive || !hasAvailableEnergy) return;

    // Process verified player move

    // Check championship context
    let shouldUseReserveEnergy = false;
    let isPlayerInChampionship = false;

    // Check if player is in an active league
    if (championship &&
        championship.currentSeason &&
        championship.playerStats &&
        championship.playerStats.hasEntryTicket) {
      isPlayerInChampionship = true;

      // Check if player needs to use energy credits
      if (energy <= 0 && championship.playerStats.reserveEnergy > 0) {
        shouldUseReserveEnergy = true;
      }
    }

    // Consume energy using the global energy system
    let success = true;
    if (energy > 0) {
      success = await consumeEnergy(1);
    } else if (shouldUseReserveEnergy && championship) {
      // Use energy credits from league
      try {
        // Use energy credits via API
        const response = await fetch('/api/championship', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            action: 'use_reserve_energy',
            seasonId: championship.currentSeason.id,
            amount: 1
          })
        });

        const data = await response.json();
        success = data.success;

        // Refresh league data if energy credits were used
        if (success) {
          championship.refreshData();
        }
      } catch (error) {
        console.error('Error using energy credits:', error);
        success = false;
      }
    } else {
      success = false; // No energy and no energy credits
    }

    if (!success) return; // Exit if energy consumption failed

    // We keep showing the game in the main screen during the whole process
    // Show player's choice immediately
    setPlayerChoice(choice);
    setLoadingResult(true);
    // Keep gameActive true to avoid showing overlay
    setGameActive(true);

    // Generate computer's choice immediately but don't show it yet
    const compChoice = generateComputerChoice(choice, difficulty);
    // Computer choice generated

    // Simulate suspense with a countdown
    setTimeout(async () => {
      // Reveal computer's choice after a brief delay
      setComputerChoice(compChoice);

      // Determine the result
      const roundResult = determineResult(choice, compChoice);
      setEssenceAwarded(null); // Reset essence award display

      // Update game statistics for the current difficulty
      if (roundResult === 'draw') {
        setGameStats(prev => ({
          ...prev,
          [difficulty]: {
            ...prev[difficulty],
            draws: prev[difficulty].draws + 1
          }
        }));
        // Round result: Draw
      } else if (roundResult === 'win') {
        setGameStats(prev => ({
          ...prev,
          [difficulty]: {
            ...prev[difficulty],
            wins: prev[difficulty].wins + 1
          }
        }));
        // Round result: Player wins

        // Award elemental essence based on the player's choice
        const essenceAmount = calculateReward(choice, difficulty);
        // Award essence to player

        // Record that essence was awarded for display purposes
        setEssenceAwarded({ type: choice, amount: essenceAmount });

        // Add to player's inventory
        addEssence(choice, essenceAmount).then(success => {
          if (success) {
            // Successfully added essence to inventory
          } else {
            // Failed to add essence to inventory
          }
        });
      } else if (roundResult === 'lose') {
        setGameStats(prev => ({
          ...prev,
          [difficulty]: {
            ...prev[difficulty],
            losses: prev[difficulty].losses + 1
          }
        }));
        // Round result: Computer wins

        // Explicitly handle loss for championship win streak reset
        if (isPlayerInChampionship && championship) {
          // Process loss directly through API to reset streak
          console.log('Processing loss for championship stats...');
          try {
            // Call to record the loss - we don't award points for losses
            championship.addPointsForGameResult(
              difficulty,
              false, // not a win
              false  // not a draw
            ).then(() => {
              // Make a separate call to refresh data after loss is recorded
              setTimeout(() => {
                championship.refreshData();
              }, 500);
            });
          } catch (error) {
            console.error('Error recording loss for championship:', error);
          }
        }
      }

      // Add the game to history with difficulty level
      const newGame = {
        id: Date.now().toString(),
        date: new Date().toISOString(), // ISO format for consistent parsing
        playerChoice: choice,
        computerChoice: compChoice,
        result: roundResult || 'unknown',
        difficulty: difficulty
      };
      setGameHistory(prev => [newGame, ...prev].slice(0, 30)); // Keep up to 30 most recent games for pagination

      // Award league points if applicable
      if (isPlayerInChampionship && championship) {
        try {
          // Log current player stats before calculations
          console.log('League stats before calculation:', {
            playerStatsWinStreak: championship.playerStats?.winStreak,
            totalGamesWon: championship.playerStats?.gamesWon,
            totalGamesPlayed: championship.playerStats?.gamesPlayed
          });

          // Determine game result
          const isWin = roundResult === 'win';
          const isDraw = roundResult === 'draw';

          // Calculate points using the league context
          const pointsResult = championship.calculateGamePoints(
            difficulty,
            isWin,
            isDraw
          );

          console.log('League points calculation from context:', {
            difficulty,
            isWin,
            isDraw,
            basePoints: pointsResult.basePoints,
            streakBonus: pointsResult.streakBonus,
            dailyBonus: pointsResult.dailyBonus,
            totalPoints: pointsResult.totalPoints,
            isDailyFirstGame: pointsResult.isDailyFirstGame,
            currentWinStreak: championship.playerStats?.winStreak || 0
          });

          // Set league points for display
          setChampionshipAwarded({
            points: pointsResult.totalPoints,
            isInChampionship: true,
            streakBonus: pointsResult.streakBonus
          });

          // Add points for the game result using the context method
          const result = await championship.addPointsForGameResult(
            difficulty,
            isWin,
            isDraw
          );

          // Always refresh data to ensure UI is updated with current win streak
          await championship.refreshData().catch(err => {
            console.error('Error refreshing league data:', err);
          });

          if (result.success) {
            if (result.pointsAwarded > 0) {
              console.log(`League points from API: ${result.pointsAwarded} points`, {
                contextCalculation: pointsResult.totalPoints,
                apiResult: result.pointsAwarded,
                match: pointsResult.totalPoints === result.pointsAwarded
              });
            } else if (isWin || isDraw) {
              console.log('No league points awarded for this game', {
                contextCalculation: pointsResult.totalPoints,
                apiResult: 0,
                match: pointsResult.totalPoints === 0
              });
            } else {
              console.log('Loss recorded in league stats (no points awarded)');
            }
          } else {
            // Only show error for wins and draws
            if (isWin || isDraw) {
              console.error('Failed to award league points');
            }

            // If no points were awarded but calculation showed points,
            // update the display to avoid confusion
            if (pointsResult.totalPoints > 0 && !result.pointsAwarded) {
              setChampionshipAwarded({
                points: 0,
                isInChampionship: true,
                streakBonus: 0
              });
            }
          }
        } catch (error) {
          console.error('Error awarding league points:', error);
          // Reset league award on error
          setChampionshipAwarded(null);
        }
      } else {
        // Make sure to reset league award if not in league
        setChampionshipAwarded(null);
      }

      // Show result in the game canvas
      setGameResult(roundResult);
      setLoadingResult(false);

      // Wait 2 seconds to let player see the result in the main screen
      // This gives time for players to see both choices and the result in the main UI
      setTimeout(() => {
        // Only now do we set gameActive to false to trigger the overlay with rewards/summary
        setGameActive(false);
      }, 2000);
    }, 800); // Shorter delay for better responsiveness
  };

  // Handle player's choice - initiates verification first
  const handlePlayerChoice = (choice: Choice) => {
    // Check if player has enough energy (regular energy or energy credits)
    if (!gameActive || !hasAvailableEnergy || verifying) return;

    console.info('Player initiating move:', choice);

    // Start verification flow
    setVerifying(true);
    setVerificationChoice(choice);

    // Set a verification timeout to prevent stuck UI if user clicks outside or verification stalls
    const verificationTimeout = setTimeout(() => {
      // If we're still in pending state after 30 seconds, reset the verification
      if (verificationState === 'pending') {
        console.warn('Verification timeout - resetting verification state');
        handleCancellation();
      }
    }, 30000); // 30 second timeout

    // Store the timeout ID in a ref so we can clear it later
    verificationTimeoutRef.current = verificationTimeout;

    // Start verification process
    handleVerification(choice);
  };

  // Change difficulty level and persist to localStorage
  const handleChangeDifficulty = (level: DifficultyLevel) => {
    console.info('Changing difficulty to:', level);
    setDifficulty(level);
    // Save to localStorage for persistence
    if (typeof window !== 'undefined') {
      localStorage.setItem('rps-difficulty', level);
    }
    resetGame();
  };

  // Handle tab change
  const handleTabChange = (tab: TabType) => {
    setActiveTab(tab);
  };

  // Handle statistics tab change
  const handleStatsTabChange = (tab: string) => {
    setStatsTabSelection(tab);
  };

  // Clear stats and history (separate function, not called automatically)
  const clearStatsAndHistory = () => {
    console.info('Clearing game stats and history');
    setGameStats({
      easy: { wins: 0, draws: 0, losses: 0 },
      medium: { wins: 0, draws: 0, losses: 0 },
      hard: { wins: 0, draws: 0, losses: 0 }
    });
    setGameHistory([]);
    // Also clear from localStorage
    if (typeof window !== 'undefined') {
      localStorage.removeItem('rps-game-stats');
      localStorage.removeItem('rps-game-history');
    }
  };

  /**
   * Handles the verification process for game moves
   */
  const handleVerification = async (choice: Choice) => {
    if (!isInstalled || verificationState === 'pending') {
      return;
    }

    // Reset states
    setVerificationState('pending');
    setVerificationError(null);

    try {
      // Request verification from World ID
      const result = await requestVerification(choice);

      // Handle cancellation from requestVerification
      if (result.cancelled) {
        console.log('User cancelled verification during request phase');
        handleCancellation();
        return;
      }

      const { finalPayload, actionId, signal } = result;

      // Continue only if we have a valid payload from successful verification request
      if (!finalPayload) {
        console.error('Missing verification payload');
        handleVerificationFailure('Verification failed. Please try again.');
        return;
      }

      // Call the simplified verification function
      const data = await verifyProof(finalPayload, actionId, signal);

      // Simplified handling of verification result
      if (!data || !data.verifyRes) {
        // Should never happen with our new implementation, but just in case
        handleVerificationFailure('Verification system error');
        return;
      }

      // Handle cancellation
      if (data.verifyRes.cancelled) {
        handleCancellation();
        return;
      }

      // Handle server errors
      if (data.verifyRes.serverError) {
        handleVerificationFailure('Verification failed. Server error. Please try again later.');
        return;
      }

      // Handle system errors
      if (data.verifyRes.systemError) {
        handleVerificationFailure('Verification failed. System error. Please try again.');
        return;
      }

      // Handle success case
      if (data.verifyRes.success) {
        console.log('Verification successful, proceeding with game move');
        setVerificationState('success');

        }

        // Short delay before proceeding with the game
        setTimeout(() => {
          setVerifying(false);
          setVerificationState(undefined);
          setVerificationChoice(null);
          processGameMove(choice);
        }, 800);
        return;
      }

      // Handle general failure case with user-friendly message
      const errorMessage = data.verifyRes.error || 'Verification failed';
      handleVerificationFailure(`${errorMessage}. Please try again.`);
      return;
    } catch (error) {
      // Handle any errors during the process
      console.error('Verification error:', error);

      // Convert technical errors to user-friendly messages
      let userFriendlyError = 'An error occurred during verification. Please try again.';

      if (error instanceof Error) {
        const errorMsg = error.message.toLowerCase();
        console.log('Detailed error message:', error.message);

        if (errorMsg.includes('cancel') || errorMsg.includes('denied') ||
            errorMsg.includes('rejected') || errorMsg.includes('closed')) {
          handleCancellation();
          return;
        } else if (errorMsg.includes('network') || errorMsg.includes('connection') ||
                   errorMsg.includes('offline')) {
          userFriendlyError = 'Network issue during verification. Please check your connection and try again.';
        } else if (errorMsg.includes('timeout')) {
          userFriendlyError = 'Verification took too long. Please try again.';
        } else if (errorMsg.includes('required') || errorMsg.includes('attribute')) {
          // Handle validation errors
          console.error('Verification validation error:', error);
          userFriendlyError = 'There was a problem with the verification request. Please try again or restart the app.';
        }
      }

      handleVerificationFailure(userFriendlyError);
    }
  };

  // Helper function to handle cancellation consistently
  const handleCancellation = () => {
    }

    // Update verification state to failed
    setVerificationState('failed');
    setVerificationError('Verification was cancelled. You can try again.');

    // Reset verification UI after a short delay
    setTimeout(() => {
      setVerifying(false);
      setVerificationState(undefined);
      setVerificationError(null);
      setVerificationChoice(null);
    }, 2000);
  };

  // Helper function to handle verification failures consistently
  const handleVerificationFailure = (errorMessage: string) => {
    }

    // Update verification state to failed
    setVerificationState('failed');
    setVerificationError(errorMessage);

    // Reset verification UI after a longer delay to allow reading the error
    setTimeout(() => {
      setVerifying(false);
      setVerificationState(undefined);
      setVerificationError(null);
      setVerificationChoice(null);
    }, 4000);
  };

  // Get essences at component level to avoid hook order issues
  const { essences } = useElementalEssences();

  // Render content based on active tab
  const renderTabContent = () => {
    switch (activeTab) {
      case 'play':
        return (
          <div className="space-y-3">
            {/* Player essence indicator */}
            <div style={{
              display: 'flex',
              justifyContent: 'center',
              padding: '0.5rem',
              marginBottom: '0.5rem',
              backgroundColor: 'rgba(255, 255, 255, 0.8)',
              borderRadius: '0.5rem',
              boxShadow: '0 1px 2px rgba(0, 0, 0, 0.1)',
              border: '1px solid rgba(229, 231, 235, 0.8)'
            }}>
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '0.75rem'
              }}>
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '0.25rem',
                  padding: '0.25rem 0.5rem',
                  backgroundColor: '#fff9ee',
                  borderRadius: '0.5rem',
                  boxShadow: 'inset 0 1px 2px rgba(0, 0, 0, 0.05)'
                }}>
                  <span style={{ fontSize: '1rem' }}>‚úä</span>
                  <span style={{ fontWeight: 600, color: '#a6752e' }}>{essences.rock}</span>
                </div>
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '0.25rem',
                  padding: '0.25rem 0.5rem',
                  backgroundColor: '#f0faff',
                  borderRadius: '0.5rem',
                  boxShadow: 'inset 0 1px 2px rgba(0, 0, 0, 0.05)'
                }}>
                  <span style={{ fontSize: '1rem' }}>‚úã</span>
                  <span style={{ fontWeight: 600, color: '#3a7ca8' }}>{essences.paper}</span>
                </div>
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '0.25rem',
                  padding: '0.25rem 0.5rem',
                  backgroundColor: '#f8f5ff',
                  borderRadius: '0.5rem',
                  boxShadow: 'inset 0 1px 2px rgba(0, 0, 0, 0.05)'
                }}>
                  <span style={{ fontSize: '1rem' }}>‚úåÔ∏è</span>
                  <span style={{ fontWeight: 600, color: '#8257db' }}>{essences.scissors}</span>
                </div>
                {championship &&
                 championship.currentSeason &&
                 championship.playerStats &&
                 championship.playerStats.hasEntryTicket && (
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.25rem',
                    padding: '0.25rem 0.5rem',
                    backgroundColor: '#eeffee',
                    borderRadius: '0.5rem',
                    boxShadow: 'inset 0 1px 2px rgba(0, 0, 0, 0.05)'
                  }}>
                    <span style={{ fontSize: '1rem' }}>‚ö°</span>
                    <span style={{ fontWeight: 600, color: '#047857' }}>{championship.playerStats.reserveEnergy} Credits</span>
                  </div>
                )}
              </div>
            </div>

            {/* League advertisement for non-league players when there's an active season */}
            {championship &&
             championship.currentSeason &&
             (!isChampionshipPlayer) && (
              <div style={{
                background: 'linear-gradient(135deg, rgba(79, 70, 229, 0.9) 0%, rgba(67, 56, 202, 0.9) 100%)',
                borderRadius: '0.75rem',
                padding: '1rem',
                color: 'white',
                boxShadow: '0 4px 12px -1px rgba(79, 70, 229, 0.4), 0 2px 6px -1px rgba(79, 70, 229, 0.3)',
                position: 'relative',
                overflow: 'hidden',
                marginBottom: '1rem',
                border: '2px solid rgba(122, 104, 255, 0.8)'
              }}>
                {/* Animation styles added via className instead */}
                <div style={{
                  position: 'absolute',
                  top: '-20px',
                  right: '-20px',
                  width: '100px',
                  height: '100px',
                  background: 'radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%)',
                  opacity: 0.3,
                  borderRadius: '50%',
                  zIndex: 1
                }}></div>
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: '0.5rem',
                  marginBottom: '0.5rem'
                }}>
                  <span style={{
                    fontSize: '1.25rem',
                    fontWeight: 'bold'
                  }}>üèÜ</span>
                  <h3 style={{
                    fontSize: '1.125rem',
                    fontWeight: 'bold',
                    margin: 0
                  }}>Season {championship.currentSeason.number}: {championship.currentSeason.name}</h3>
                </div>
                <p style={{
                  fontSize: '0.9rem',
                  marginBottom: '0.75rem',
                  lineHeight: 1.4
                }}>
                  Join the League now to compete for rewards! Earn points, rise through the ranks, and unlock energy credits.
                </p>

                {/* League benefits grid */}
                <div style={{
                  display: 'grid',
                  gridTemplateColumns: 'repeat(2, 1fr)',
                  gap: '0.5rem',
                  marginBottom: '0.75rem'
                }}>
                  <div style={{
                    backgroundColor: 'rgba(255, 255, 255, 0.15)',
                    padding: '0.5rem',
                    borderRadius: '0.375rem',
                    textAlign: 'center'
                  }}>
                    <div style={{
                      fontSize: '0.875rem',
                      fontWeight: 'bold',
                      marginBottom: '0.125rem'
                    }}>‚ö° Energy Credits</div>
                    <div style={{
                      fontSize: '0.75rem'
                    }}>Play more games</div>
                  </div>
                  <div style={{
                    backgroundColor: 'rgba(255, 255, 255, 0.15)',
                    padding: '0.5rem',
                    borderRadius: '0.375rem',
                    textAlign: 'center'
                  }}>
                    <div style={{
                      fontSize: '0.875rem',
                      fontWeight: 'bold',
                      marginBottom: '0.125rem'
                    }}>üèÖ Rank Up</div>
                    <div style={{
                      fontSize: '0.75rem'
                    }}>Compete on leaderboard</div>
                  </div>
                  <div style={{
                    backgroundColor: 'rgba(255, 255, 255, 0.15)',
                    padding: '0.5rem',
                    borderRadius: '0.375rem',
                    textAlign: 'center'
                  }}>
                    <div style={{
                      fontSize: '0.875rem',
                      fontWeight: 'bold',
                      marginBottom: '0.125rem'
                    }}>üéÅ Rewards</div>
                    <div style={{
                      fontSize: '0.75rem'
                    }}>Win special items</div>
                  </div>
                  <div style={{
                    backgroundColor: 'rgba(255, 255, 255, 0.15)',
                    padding: '0.5rem',
                    borderRadius: '0.375rem',
                    textAlign: 'center'
                  }}>
                    <div style={{
                      fontSize: '0.875rem',
                      fontWeight: 'bold',
                      marginBottom: '0.125rem'
                    }}>üî• Win Streaks</div>
                    <div style={{
                      fontSize: '0.75rem'
                    }}>Bonus points multiplier</div>
                  </div>
                </div>
                <button
                  onClick={() => handleTabChange('championship')}
                  style={{
                    backgroundColor: 'white',
                    color: '#4f46e5',
                    border: 'none',
                    padding: '0.75rem 1rem',
                    borderRadius: '0.5rem',
                    fontWeight: 'bold',
                    fontSize: '1rem',
                    cursor: 'pointer',
                    boxShadow: '0 2px 5px rgba(0, 0, 0, 0.2)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    width: '100%',
                    transition: 'all 0.2s ease',
                    position: 'relative',
                    overflow: 'hidden'
                  }}
                  onMouseOver={(e) => {
                    e.currentTarget.style.transform = 'translateY(-2px)';
                    e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.transform = 'translateY(0)';
                    e.currentTarget.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
                  }}
                >
                  <span style={{ marginRight: '0.5rem', fontSize: '1.2rem' }}>üèÜ</span>
                  Join League Now!
                  <span style={{ marginLeft: '0.5rem' }}>‚Üí</span>
                </button>
              </div>
            )}

            {/* Game arena with separate status bar and game area */}
            <div className="space-y-1">
              {/* Status banner */}
              <StatusBar
                result={gameResult}
                loadingResult={loadingResult}
                playerChoice={playerChoice}
                computerChoice={computerChoice}
                getStatusMessage={() => getResultMessage(gameResult)}
                getStatusStyle={() => getStatusBarStyle(gameResult, loadingResult)}
              />

              {/* Game arena display */}
              <GameArena
                playerChoice={playerChoice}
                computerChoice={computerChoice}
                loadingResult={loadingResult}
              />
            </div>

            {/* Game controls (difficulty selector and player choice buttons) */}
            <GameControls
              difficulty={difficulty}
              onChangeDifficulty={handleChangeDifficulty}
              onChoiceSelect={handlePlayerChoice}
              gameActive={gameActive}
              loadingResult={loadingResult}
              energy={energy}
              playerChoice={playerChoice}
              hasEnergyCredits={hasEnergyCredits}
            />
          </div>
        );
      case 'history':
        return <HistoryTab recentGames={gameHistory} onClear={clearStatsAndHistory} />;
      case 'statistics':
        return <StatisticsTab
          gameStats={gameStats}
          selectedStatsTab={statsTabSelection}
          onStatsTabChange={handleStatsTabChange}
          onReset={clearStatsAndHistory}
        />;
      case 'energy':
        // Only show energy tab content if player is a league player
        if (!isChampionshipPlayer) {
          return (
            <div className="flex flex-col items-center justify-center p-6 text-center space-y-4">
              <div className="text-5xl mb-3">üîí</div>
              <div className="text-xl font-bold mb-1">Energy Credits Locked</div>
              <div className="text-sm text-gray-600 max-w-xs">
                Join the League to unlock the ability to purchase energy credits and play more games!
              </div>
              <button
                onClick={() => setActiveTab('championship')}
                className="mt-4 px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors"
              >
                Go to League
              </button>
            </div>
          )
        }
        // Use the championship context from component level
        const { purchaseReserveEnergy } = championship || {};

        // Handle energy credits purchase
        const handlePurchaseReserveEnergy = async (size: 'small' | 'medium' | 'large') => {
          if (!championship || !championship.purchaseReserveEnergy) {
            console.error('Championship context not available');
            return false;
          }

          try {
            const success = await championship.purchaseReserveEnergy(size);
            if (success) {
              console.log(`Energy credits (${size}) purchased successfully`);
              return true;
            } else {
              console.error(`Failed to purchase energy credits (${size})`);
              return false;
            }
          } catch (error) {
            console.error('Error purchasing energy credits:', error);
            return false;
          }
        };

        return (
          <div className="space-y-4">
            
            <div style={{
                padding: '0.5rem',
                backgroundColor: '#f0fdf4',
                borderRadius: '0.375rem',
                borderLeft: '4px solid #10b981',
                fontSize: '0.875rem'
              }}>
                Purchase energy credits to continue playing when your regular energy is depleted!
              </div>

            {purchaseReserveEnergy && (
              <EnergyPurchase
                onPurchase={handlePurchaseReserveEnergy}
                essences={essences}
                championship={championship}
              />
            )}
          </div>
        );
      case 'championship':
        return (
          <Suspense fallback={
            <div className="p-4 text-center">
              <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-purple-500 mx-auto mb-4"></div>
              <p>Loading championship data...</p>
            </div>
          }>
            <SeasonalChampionship />
          </Suspense>
        );
      default:
        return null;
    }
  };

  return (
    <div className="w-full max-w-md mx-auto my-8 relative">
      {/* Overarching header that sits on top */}
      <GameHeader title="Rock Paper Scissors" />
      
      {/* Main game container with padding at top for header overlap */}
      <div
        className="w-full rounded-xl shadow-sm"
        style={{
          backgroundColor: '#f0f0f0',
          borderColor: '#e0e0e0',
          borderWidth: '2px',
          borderStyle: 'solid',
          color: '#333',
          borderRadius: '1rem',
          overflow: 'hidden',
          position: 'relative',
          marginTop: '0.5rem' // Push content down to accommodate header
        }}
      >
        {/* Tab navigation under the header */}
        <TabNavigation
          activeTab={activeTab}
          onTabChange={handleTabChange}
          showChampionship={true} // Enable championship tab
          isChampionshipPlayer={isChampionshipPlayer} // Pass championship player status
        />
        
        {/* Tab content container */}
        <div
          style={{
            padding: '1rem',
            paddingTop: '2.5rem', /* Add extra padding at top for tab navigation */
          }}
        >
          {renderTabContent()}
        </div>

        {/* Verification overlay */}
        {activeTab === 'play' && (
          <VerificationOverlay
            verifying={verifying}
            verificationChoice={verificationChoice}
            verificationState={verificationState}
            verificationError={verificationError}
          />
        )}

        {/* Result overlay */}
        {activeTab === 'play' && (
          <ResultOverlay
            active={!gameActive}
            energy={energy}
            result={gameResult}
            essenceAwarded={essenceAwarded}
            championshipAwarded={championshipAwarded}
            loadingResult={loadingResult}
            onReset={resetRound}
            championship={championship}
            onOpenLeague={() => handleTabChange(isChampionshipPlayer ? 'energy' : 'championship')}
          />
        )}
      </div>
    </div>
  );
};

export default RockPaperScissors;